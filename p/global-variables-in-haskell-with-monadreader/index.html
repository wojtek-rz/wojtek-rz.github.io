<!doctype html><html lang=en-gb dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Understanding the MonadReader class in Haskell"><title>Global variables in Haskell with MonadReader!</title>
<link rel=canonical href=https://wojtek-rz.github.io/p/global-variables-in-haskell-with-monadreader/><link rel=stylesheet href=/scss/style.min.2eb51b5cb500d6ffa39a5cc4303f6a57d40117e2a520061289a834c815b9b01f.css><meta property='og:title' content="Global variables in Haskell with MonadReader!"><meta property='og:description' content="Understanding the MonadReader class in Haskell"><meta property='og:url' content='https://wojtek-rz.github.io/p/global-variables-in-haskell-with-monadreader/'><meta property='og:site_name' content="Wojtek Rzeplinski's website"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Haskell'><meta property='article:tag' content='Monads'><meta property='article:tag' content='Functional programming'><meta property='article:published_time' content='2024-03-30T00:00:00+00:00'><meta property='article:modified_time' content='2024-03-30T00:00:00+00:00'><meta name=twitter:title content="Global variables in Haskell with MonadReader!"><meta name=twitter:description content="Understanding the MonadReader class in Haskell"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu8172189377105849349.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Wojtek Rzeplinski's website</a></h1><h2 class=site-description>Machine learning student at the University of Warsaw.</h2></div></header><ol class=menu-social><li><a href=https://github.com/wojtek-rz target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/wojtekrzeplinski/ target=_blank title=Linkedin rel=me><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><ol><li><a href=#motivation>Motivation</a></li><li><a href=#implementation-details>Implementation details</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/tutorials/>Tutorials</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/global-variables-in-haskell-with-monadreader/>Global variables in Haskell with MonadReader!</a></h2><h3 class=article-subtitle>Understanding the MonadReader class in Haskell</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 30, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>7 minute read</time></div></footer></div></header><section class=article-content><h1 id=what-is-monad-reader-in-haskell><a href=#what-is-monad-reader-in-haskell class=header-anchor></a>What is Monad Reader in Haskell?</h1><p>Understanding the <code>MonadReader</code> class in Haskell can be challenging.
Online tutorials often focus on implementation details rather than its purpose and usefulness.
By the end of this post, you&rsquo;ll have a clear understanding of how MonadReader streamlines
environment passing in Haskell, making your code cleaner and more maintainable.</p><h3 id=motivation><a href=#motivation class=header-anchor></a>Motivation</h3><p>The term &lsquo;monad reader&rsquo; comes from the idea that all functions read from a common source.</p><p>For example, suppose you have a global configuration variable that several functions read from.
By using a MonadReader, you can avoid passing that configuration as an argument to each function.
The result of our monad would be a function takes this global variable as an argument and
then passes it to each function within it.</p><p>Here is a simple example. Suppose we are calculating the total cost of a trip to Europe.
We visit three countries, each with its own currency:
GBP in the UK, EUR in France and CHF in Switzerland.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>type</span> <span class=kt>ExchangeRate</span> <span class=ow>=</span> <span class=kt>String</span> <span class=ow>-&gt;</span> <span class=kt>Double</span>
</span></span><span class=line><span class=cl><span class=nf>exchangeRateToPln</span> <span class=ow>::</span> <span class=kt>ExchangeRate</span>
</span></span><span class=line><span class=cl><span class=nf>exchangeRateToPln</span> <span class=s>&#34;EUR&#34;</span> <span class=ow>=</span> <span class=mf>4.3</span>
</span></span><span class=line><span class=cl><span class=nf>exchangeRateToPln</span> <span class=s>&#34;GBP&#34;</span> <span class=ow>=</span> <span class=mf>4.9</span>
</span></span><span class=line><span class=cl><span class=nf>exchangeRateToPln</span> <span class=s>&#34;CHF&#34;</span> <span class=ow>=</span> <span class=mf>3.9</span>
</span></span></code></pre></td></tr></table></div></div><p>We want to pass a dictionary of currency rates to any function that needs them.
The functions can have different numbers of arguments,
but they have one thing in common - <strong>the last argument is of type <code>ExchangeRate</code></strong>.
(the implementation is not important here).</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>getSwitzerlandCost</span> <span class=ow>::</span> <span class=kt>Int</span> <span class=ow>-&gt;</span> <span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>ExchangeRate</span> <span class=ow>-&gt;</span> <span class=kt>Double</span>
</span></span><span class=line><span class=cl><span class=nf>getSwitzerlandCost</span> <span class=n>days</span> <span class=n>nightCost</span> <span class=n>rate</span> <span class=ow>=</span> <span class=n>fromIntegral</span> <span class=n>days</span> <span class=o>*</span> <span class=n>nightCost</span> <span class=o>*</span> <span class=n>rate</span> <span class=s>&#34;CHF&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>getUKCost</span> <span class=ow>::</span> <span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>ExchangeRate</span> <span class=ow>-&gt;</span> <span class=kt>Double</span>
</span></span><span class=line><span class=cl><span class=nf>getUKCost</span> <span class=n>flightCost</span> <span class=n>rate</span> <span class=ow>=</span> <span class=mf>2.0</span> <span class=o>*</span> <span class=n>flightCost</span> <span class=o>*</span> <span class=n>rate</span> <span class=s>&#34;GBP&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>getFranceCost</span> <span class=ow>::</span> <span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>ExchangeRate</span> <span class=ow>-&gt;</span> <span class=kt>Double</span>
</span></span><span class=line><span class=cl><span class=nf>getFranceCost</span> <span class=n>distance</span> <span class=n>fuelCost</span> <span class=n>rate</span> <span class=ow>=</span> <span class=mf>2.0</span> <span class=o>*</span> <span class=n>distance</span> <span class=o>*</span> <span class=n>fuelCost</span> <span class=o>*</span> <span class=n>rate</span> <span class=s>&#34;EUR&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>Calculating the total cost is now straightforward:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>calculateTotalCost</span> <span class=ow>::</span> <span class=kt>ExchangeRate</span> <span class=ow>-&gt;</span> <span class=kt>Double</span>
</span></span><span class=line><span class=cl><span class=nf>calculateTotalCost</span> <span class=n>exchangeRateToPln</span> <span class=ow>=</span> 
</span></span><span class=line><span class=cl>    <span class=kr>let</span> <span class=n>switzerlandCost</span> <span class=ow>=</span> <span class=n>getSwitzerlandCost</span> <span class=mi>7</span> <span class=mf>100.0</span>  <span class=n>exchangeRateToPln</span>
</span></span><span class=line><span class=cl>        <span class=n>ukCost</span>          <span class=ow>=</span> <span class=n>getUKCost</span> <span class=mf>200.0</span>             <span class=n>exchangeRateToPln</span>
</span></span><span class=line><span class=cl>        <span class=n>franceCost</span>      <span class=ow>=</span> <span class=n>getFranceCost</span> <span class=mf>1000.0</span> <span class=mf>1.5</span>    <span class=n>exchangeRateToPln</span>
</span></span><span class=line><span class=cl>        <span class=kr>in</span> <span class=p>(</span><span class=n>switzerlandCost</span> <span class=o>+</span> <span class=n>ukCost</span> <span class=o>+</span> <span class=n>franceCost</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Maybe we could get rid of the repetitive <code>exchangeRateToPln</code>? That&rsquo;s what
Monad Reader does. It hides the last argument of each function call,
so that it behaves like an abstract global variable that is passed unchanged to every
to any function in our monad. It is often called the <code>config</code> or <code>environment</code> argument.
The syntax of our monad is as follows:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>calculateTotalCost</span> <span class=ow>::</span> <span class=kt>ExchangeRate</span> <span class=ow>-&gt;</span> <span class=kt>Double</span>
</span></span><span class=line><span class=cl><span class=nf>calculateTotalCost</span> <span class=ow>=</span> <span class=kr>do</span>
</span></span><span class=line><span class=cl>    <span class=n>switzerlandCost</span> <span class=ow>&lt;-</span> <span class=n>getSwitzerlandCost</span> <span class=mi>7</span> <span class=mf>100.0</span>
</span></span><span class=line><span class=cl>    <span class=n>ukCost</span> <span class=ow>&lt;-</span> <span class=n>getUKCost</span> <span class=mf>200.0</span>
</span></span><span class=line><span class=cl>    <span class=n>franceCost</span> <span class=ow>&lt;-</span> <span class=n>getFranceCost</span> <span class=mf>1000.0</span> <span class=mf>1.5</span>
</span></span><span class=line><span class=cl>    <span class=n>return</span> <span class=p>(</span><span class=n>switzerlandCost</span> <span class=o>+</span> <span class=n>ukCost</span> <span class=o>+</span> <span class=n>franceCost</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>What if we want to write something like <code>gifts &lt;- 100</code>? The <code>100</code> is a value,
not a function that takes <code>ExchangeRate</code> as its last argument. We would write
<code>gifts &lt;- return 100</code> and that&rsquo;s the monadic way to do it.</p><p>Believe it or not, but in the last code example we actually used a MonadReader.
The monadic type here is <code>ExchangeRate -> Double</code>, but we can abstract away
the implementation details here and write it with the <code>Reader</code> constructor
from <code>Control.Monad.Reader</code> library:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>calculateTotalCost</span> <span class=ow>::</span> <span class=kt>ExchangeRate</span> <span class=ow>-&gt;</span> <span class=kt>Double</span>
</span></span><span class=line><span class=cl><span class=c1>-- is the same as</span>
</span></span><span class=line><span class=cl><span class=nf>calculateTotalCost</span> <span class=ow>::</span> <span class=kt>Reader</span> <span class=kt>ExchangeRate</span> <span class=kt>Double</span>
</span></span><span class=line><span class=cl><span class=c1>-- in general:</span>
</span></span><span class=line><span class=cl><span class=c1>-- Reader Env(last argument of functions / environment) Value(return value of the monad) </span>
</span></span></code></pre></td></tr></table></div></div><p>What if we want to store <code>Environment</code> value in a &ldquo;variable&rdquo;? That&rsquo;s what identity function does:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>calculateTotalCost</span> <span class=ow>=</span> <span class=kr>do</span>
</span></span><span class=line><span class=cl>    <span class=n>exchangeRate</span> <span class=ow>&lt;-</span> <span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=n>x</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>We can also run some function with changed environment. The most popular use case is when writing interpreters,
but let&rsquo;s say we want to calculate the cost of our trip if the economic crisis were to hit.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>changeToCrisisRates</span> <span class=ow>::</span> <span class=kt>ExchangeRate</span> <span class=ow>-&gt;</span> <span class=kt>ExchangeRate</span>
</span></span><span class=line><span class=cl><span class=nf>changeToCrisisRates</span> <span class=n>rates</span> <span class=n>currency</span> <span class=ow>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>rates</span> <span class=n>currency</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>calculateTotalCostWhenCrisis</span> <span class=ow>::</span> <span class=kt>ExchangeRate</span> <span class=ow>-&gt;</span> <span class=kt>Double</span>
</span></span><span class=line><span class=cl><span class=nf>calculateTotalCostWhenCrisis</span> <span class=ow>=</span> <span class=kr>do</span>
</span></span><span class=line><span class=cl>    <span class=n>rates</span> <span class=ow>&lt;-</span> <span class=n>id</span>
</span></span><span class=line><span class=cl>    <span class=n>return</span> <span class=p>(</span><span class=n>calculateTotalCost</span> <span class=p>(</span><span class=n>changeToWarRates</span> <span class=n>rates</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>Here we have a function that changes the environment <code>changeToCrisisRates :: ExchangeRate -> ExchangeRate</code>
and we run the <code>calculateTotalCost</code> calculation with the modified environment.</p><p>These two applications are so common,
that they deserve separate functions within the MonadReader class:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>ask</span> <span class=ow>::</span> <span class=kt>Reader</span> <span class=kt>Env</span> <span class=kt>Env</span> 
</span></span><span class=line><span class=cl><span class=c1>-- monad that returns Env</span>
</span></span><span class=line><span class=cl><span class=nf>local</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Env</span> <span class=ow>-&gt;</span> <span class=kt>Env</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=kt>Reader</span> <span class=kt>Env</span> <span class=kt>Val</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=kt>Reader</span> <span class=kt>Env</span> <span class=kt>Val</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=c1>-- Given a function to modify Env and current calculation,</span>
</span></span><span class=line><span class=cl><span class=c1>-- return calculation that would run with modified Env.</span>
</span></span></code></pre></td></tr></table></div></div><p>Type <code>Env</code> denotes the environment type, which in our example
is <code>ExchangeRate</code>.</p><p>Another useful function is <code>asks</code> which helps with the problem: what if I want to get
only part of Env, not the whole Env.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>asks</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Env</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=kt>Reader</span> <span class=kt>Env</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=c1>-- given Env selector, create calculation that </span>
</span></span><span class=line><span class=cl><span class=c1>-- runs selector on Env and returns the value</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=implementation-details><a href=#implementation-details class=header-anchor></a>Implementation details</h3><p>Let&rsquo;s try to implement this monad. What is a monadic type here?
Remember, that left arrow <code>&lt;-</code> notation is a syntax for <code>>>=</code> with lambda expressions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>calculateCost</span> <span class=ow>=</span> <span class=kr>do</span>
</span></span><span class=line><span class=cl>    <span class=n>value</span> <span class=ow>&lt;-</span> <span class=n>getUKCost</span> <span class=mf>200.0</span>
</span></span><span class=line><span class=cl>    <span class=n>return</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>-- is equal to</span>
</span></span><span class=line><span class=cl><span class=nf>calculateCost</span> <span class=ow>=</span> <span class=kr>do</span>
</span></span><span class=line><span class=cl>    <span class=n>getUKCost</span> <span class=mf>200.0</span> <span class=o>&gt;&gt;=</span> <span class=p>(</span><span class=nf>\</span><span class=n>value</span> <span class=ow>-&gt;</span> <span class=n>return</span> <span class=n>value</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>So <code>getUKCost 200.0</code> is of type <code>ExchangeRate -> Double</code> which should be our monadic
value. More generally, if <code>m</code> is our monad we would like to have:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>m a == Env -&gt; a
</span></span></code></pre></td></tr></table></div></div><p>So here, the monad is a function, that takes environment and returns a value.
A useful interpetation is that monads are containers for some values.
How can a function be a container? Actually, if we have a function `_ -> 10&rsquo;
then no matter what we give it as an argument we will get 10.
This makes it 100% certain to hold the value 10. How do we chain such monads?
We would like to implement bind function with type:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=p>(</span><span class=o>&gt;&gt;=</span><span class=p>)</span> <span class=ow>::</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=o>&gt;&gt;=</span><span class=p>)</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Env</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=kt>Env</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>It takes a monadic value with type <code>m a</code> and passed the value <code>a</code> to the function,
which returns the monadic value <code>m b</code>. But to get value <code>a</code> from monad
<code>Env -> a</code> we have to pass <code>Env</code>. And that&rsquo;s exacly how we implement it:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>h</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=nf>\</span><span class=n>w</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=p>(</span><span class=n>h</span> <span class=n>w</span><span class=p>)</span> <span class=n>w</span>
</span></span></code></pre></td></tr></table></div></div><p>We get the value from <code>h</code> with <code>h w</code> and pass it to <code>f</code>. Because the result of bind
must also have monadic value <code>m b == Env -> b</code>, and the result of <code>f</code> is a value
inside the function container, we have to pass again <code>w</code> to the result <code>f (h w)</code> to
get the value inside the monad.</p><p>And even pure arithmetic has an interesting interpretation. It is a calculation
that ignores the result and always returns the value.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>return</span> <span class=n>a</span> <span class=ow>=</span> <span class=nf>\</span><span class=kr>_</span> <span class=ow>-&gt;</span> <span class=n>a</span>
</span></span></code></pre></td></tr></table></div></div><p>In many places you will see such implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=p>((</span><span class=ow>-&gt;</span><span class=p>)</span> <span class=n>r</span><span class=p>)</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>    <span class=n>return</span> <span class=n>x</span> <span class=ow>=</span> <span class=nf>\</span><span class=kr>_</span> <span class=ow>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=n>h</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=nf>\</span><span class=n>w</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=p>(</span><span class=n>h</span> <span class=n>w</span><span class=p>)</span> <span class=n>w</span>
</span></span></code></pre></td></tr></table></div></div><p>where the most confusing part is this <code>((->) r)</code>. This is type constructor which
is missing the argument - value it will take. With list monad we have:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>instance</span> <span class=kt>Monad</span> <span class=kt>[]</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>    <span class=n>xs</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>concat</span> <span class=o>$</span> <span class=n>map</span> <span class=n>f</span> <span class=n>xs</span>
</span></span><span class=line><span class=cl>    <span class=n>return</span> <span class=n>x</span> <span class=ow>=</span> <span class=p>[</span><span class=n>x</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>and <code>[]</code> is a constructor that is also missing value. For example if we write <code>[] Int</code>,
we give the type constructor <code>[]</code> type <code>Int</code> and the result is <code>[Int]</code>. So we can say that
<code>[]</code> is of <em>kind</em> <code>* -> *</code>, where <code>*</code> is a type. Even more, <code>(->) r</code> is also a type
constructor of kind <code>* -> *</code>. If we give it the type <code>String</code> we get <code>(->) r String</code> which
can be also written as <code>r -> String</code>. In the Haskell documentation, <code>m = (->) r</code>, so <code>m</code>
is a monad type constructor. Therefore <code>m a</code> expands to <code>r -> a</code>.</p><p>Useful exercises are writing <code>functor</code> and <code>applicative</code> instances for the monad function,
as well as <code>ask</code> and <code>local</code> functions (I explained what they do in the previous section).
These implementations are:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=kr>class</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=kt>MonadReader</span> <span class=n>r</span> <span class=n>m</span> <span class=o>|</span> <span class=n>m</span> <span class=ow>-&gt;</span> <span class=n>r</span> <span class=kr>where</span>
</span></span><span class=line><span class=cl>    <span class=n>ask</span> <span class=ow>::</span> <span class=n>m</span> <span class=n>r</span> <span class=c1>-- we now now that m r expands to r -&gt; r, so only id fits</span>
</span></span><span class=line><span class=cl>    <span class=n>ask</span> <span class=ow>=</span> <span class=n>id</span>
</span></span><span class=line><span class=cl>    <span class=n>local</span> <span class=ow>::</span> <span class=p>(</span><span class=n>r</span> <span class=ow>-&gt;</span> <span class=n>r</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>    <span class=n>local</span> <span class=n>f</span> <span class=n>previousReader</span> <span class=n>env</span> <span class=ow>=</span> <span class=n>previousReader</span> <span class=p>(</span><span class=n>f</span> <span class=n>env</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>And that is how we can play with MonadReader.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/haskell/>Haskell</a>
<a href=/tags/monads/>Monads</a>
<a href=/tags/functional-programming/>Functional Programming</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/numpy-explained-meshgrid-function/><div class=article-details><h2 class=article-title>NumPy explained - meshgrid function</h2></div></a></article><article><a href=/p/dive-into-your-assembly-code/><div class=article-details><h2 class=article-title>Dive into your assembly code!</h2></div></a></article><article><a href=/p/one-word-on-copy-constructors/><div class=article-details><h2 class=article-title>One Word on Copy Constructors</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2024 Wojtek Rzeplinski's website</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.27.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>